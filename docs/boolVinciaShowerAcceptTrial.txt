@startuml

start

:#yellow:Mark this trial as "used", will need to generate a new one.;

:Count up total number of trials;

:#yellow: Generate zeta variable, then work out y12, y23 \n --------------- \n <u><font size="6">Branchelemental* winnerPtr;</u> -> <u>bool Branchelemental::genTrialInvariants(double& y12, double& y23, int iTrial = -1)</font></u>;
	
if ( [trial invariants are not in the good region of P.S.] \n <u><font size="6">Branchelemental* winnerPtr;</u> -> <u>bool Branchelemental::genTrialInvariants(double& y12, double& y23, int iTrial = -1)</font></u>) then ([true])
  :Count up local and global failure rate due to hull; 
  stop
else ([else])
endif

:#yellow: Compute spin-summed trial antenna sum for these variables \n --------------- \n <u><font size="6">Branchelemental* winnerPtr;</u> -> <u>int Branchelemental::nTrialGenerators() const</font></u>;

:#yellow: Set flavors to the particles in the winner branchelemental;

:#yellow: Treatment of Masses;

:Check massive phase-space boundaries;
note right: may involve return [false]

:#yellow:Check hadronization veto(s) 1;
note left
here only check branching invariants. 
Invariants with respect to neighbors can optionally be checked 
after the branching kinematics have been fully defined, below.
-----
Require all color-connected invariants at least above lowest
physical meson mass
(consistent with length > thickness assumption of string model)
end note

fork
 :branching invariant 12;
 :#white: Hadronization test;
 note right: may involve return [false]

fork again
:branching invariant 23;
:#white: Hadronization test;
note right: may involve return [false]

fork again
:Check hadronization cutoff: Ariadne pT or alternatives;
:#white:Check cutoffScale;
note right: may involve return [false]

end fork

:#yellow:Construct flag for helicity of mother partons;

:#yellow:If physical antenna function is mirror of current trial, translate to
   swapped invariants for antenna-function evaluation;

:#yellow:
    // Compute spin-summed physical antennae (spin selection below)
    // Store result in vector representing uncertainty variations
    // iVar = 0 : User settings
    //        1 : Vincia defaults
    //        2 : AlphaS-Hi (with def ants)
    //        3 : AlphaS-Lo (with def ants)
    //        4 : Ant-Hi    (with def alphaS)
    //        5 : Ant-Lo    (with def alphaS)
    //        6 : NLO-Hi    (with def ants & alphaS)
    //        7 : NLO-Lo    (with def ants & alphaS)
    //        8 : Ord-Var1  -"-
    //        9 : Ord-Var2  -"-
    //       10 : NLC-Hi    -"-
    //       11 : NLC-Lo    -"-
    // Global shower: Pimp * Pari * ant-global
    // Global matched: Pimp * Pari * PME * ant-global
    // Sector shower: ant-sector
    // Sector matched: ME(n+1)/ME(n)
           --------
<font size="6"><u>Antenna* VinciaShower::getAnt(int iAnt, bool isSectorIn=false, int iSet=0)</font></u>;

if ( ) then ([Unpolarized case: ignore parent helicities])
:...
-----
<font size="6"><u>Antenna* antUsrPtr </u>-><u> <b>POLY</b> virtual double antennaFunction(double yij, double yjk,...)
<font size="6"><u>Antenna* antDefPtr </u>-><u> <b>POLY</b> virtual double antennaFunction(double yij, double yjk,...)
<font size="6"><u>Antenna* antMaxPtr </u>-><u> <b>POLY</b> virtual double antennaFunction(double yij, double yjk,...)
<font size="6"><u>Antenna* antMinPtr </u>-><u> <b>POLY</b> virtual double antennaFunction(double yij, double yjk,...);

else ( [Polarized case: use parent helicities, but restrict to massless] )

:...
-----
<font size="6"><u>Antenna* antUsrPtr </u>-><u> <b>POLY</b> virtual double antennaFunction(double yij, double yjk,...)
<font size="6"><u>Antenna* antDefPtr </u>-><u> <b>POLY</b> virtual double antennaFunction(double yij, double yjk,...)
<font size="6"><u>Antenna* antMaxPtr </u>-><u> <b>POLY</b> virtual double antennaFunction(double yij, double yjk,...)
<font size="6"><u>Antenna* antMinPtr </u>-><u> <b>POLY</b> virtual double antennaFunction(double yij, double yjk,...);

endif

: Apply color (charge) factor;

: Compute Pimp and Pari modifications (only applied to global showers);

fork
:#white: Pimp (allows suppressed unordered branchings);
fork again
:#white: Pari  (ARIADNE factor for g->qq splittings)
    Only for global showers, when neighbor is a final-state quark;
end fork

:#yellow: HYPERJET: special mode for processing events from HEJ
    => matching to soft-resummed matrix elements
    Ignore otherwise;

:#yellow: Effiency step: Pure shower accept/reject, before doing full kinematics;
note left
only if no uncertainty bands and only for global showers;
for sector showers, the full kinematics are needed to know if the branching
will be vetoed, thus the accept probability can actually be crazy at
this point if we are in the wrong sector. For uncertainty bands, the
correct reweighting of the uncertainty variations has not yet been
worked out in the presence of an intermediate accept/reject here.
---
matching corrections still to be applied, done below;
end note

:#yellow: Generate full kinematics for this trial branching;

:Generate random (uniform) phi angle;
:Generate branching kinematics, starting from dipole-antenna parents
---------------
<u><font size="6">Antenna* antUsrPtr</u> -> <u>int   getKineMapType()</font></u>
<u><font size="6"> <b>POLY</b> VinClu* vinCluPtr; </u> -> <u>bool map2to3(vector<Vec4>& pThree, vector<Vec4> pTwo, int kineMapTypeIn, double y12, double y23, double phi, ...)</font></u>;

:#yellow: *)Optional: check sector ordering (if doing sector showers)
-------
<u><font size="6"> bool VinciaShower::sectorAccept(Event& event,Branchelemental* trialPtr)</font></u>;
note right: may involve return [false]

:#yellow: Check hadronization veto(s) 2;
note left
here only check neighbor invariants. Branching invariants were
already checked above.
--
for neighbors, we are only checking invariant mass > pion mass.
Could in principle be made more elaborate by checking cutoffScale
as well, given sufficient reason to do so.
end note

:#yellow:  Choose helicities for daughter particles
(so far only for massless polarized shower);

:#yellow: Set mother and color-flow information in the event record;

:#yellow: Set masses in the event record;

note left
MR 17.7.2010: there is a problem with particles which are
off-shell by more than TINY, set the masses based on ID and
check off-shellness here
----
PS 23.2.2011: changed denominator in offshell to sP instead of qNew
and modified linear to squared dependence, since that's really what
the numerical precision is driven by
end note

:check off-shellness;
note right
may involve return [false]
end note

stop

@enduml